import React, { useEffect, useState, useCallback } from "react";
import Navbar from "@/components/Navbar";
// useSearchParams removed as it's no longer used for passing user data this way
// import { useSearchParams } from "react-router-dom";
import { useToast } from "@/components/ui/use-toast";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Wallet, Github, Star, GitFork, Code, ExternalLink, Award } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import axios from "axios";
import { formatUnits, parseUnits, isAddress } from "ethers"; // <-- Import parseUnits
import { Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { CircleHelp, Clock } from "lucide-react"; // Add icons for status
import { ethers } from "ethers";


const UCOIN_DECIMALS = 18;

// --- Updated Contract ABIs and Addresses ---
import UserDatabaseABI from "../abis/UserDatabase.json";
import RewardMechanismABI from "../abis/RewardMechanism.json";
import UCoinABI from "../abis/UCoin.json"
const CONTRACT_ADDRESSES = {
  userDatabase: "0xe92cFff8436007F804F2ec05AF83851AD3dA9945", // Your new address
  rewardMechanism: "0xaF6b1E1A7A7A7D94FE7d571E269582e8F94EC561", // Your new address
  ucoin: "0x383125a9312fbc54a62d08e1638628C6BB7B77f7" // Your new address
};
const registerUserOnChain = async (username, xp) => {
  if (!window.ethereum) {
    alert("Please install Metamask");
    return;
  }

  const provider = new ethers.providers.Web3Provider(window.ethereum);
  const signer = provider.getSigner();
  const contract = new ethers.Contract(contractAddress, UserDatabaseABI, signer);

  try {
    const tx = await contract.setUserWithXP(username, xp);
    await tx.wait();
    console.log("User registered on-chain with XP:", username, xp);
  } catch (error) {
    console.error("Error registering user on-chain:", error);
  }
};

const handleXPSubmit = async () => {
  const username = githubUsername; // Already fetched from GitHub API
  const xp = totalContributions * 50;

  await registerUserOnChain(username, xp);
};

// --- NEW: Function to calculate tokens for a SPECIFIC level ---
const calculateTokensForLevel = (level) => {
  if (level <= 0) return 0;
  return (5 * Math.pow(1.08, level));
};
const calculateTotalTokensFromXps = (xps) => {
  const { level } = calculateLevelAndTitle(xps);
  let totalTokens = 0;

  for (let i = 1; i <= level; i++) {
    totalTokens += calculateTokensForLevel(i);
  }

  return totalTokens;
};
//const totalTokensEarned = calculateTotalTokensFromXps(contributionStats.xps); // Replace xps with actual XP value


// Utility Functions (calculateLevelAndTitle, determineRole remain similar)
const calculateLevelAndTitle = (xps) => {
    let level = 0;
    let requiredXps = 0;
    if (xps < 0) xps = 0; // Handle potential negative XP

    // Calculate level based on XP
    // XP needed for level L = L * (L+1) * 50
    while (requiredXps <= xps) {
        level++;
        requiredXps = (level * (level + 1) * 50);
    }
    level--; // Adjust to the correct level (the last one fully achieved)
    level = Math.max(0, level); // Ensure level is not negative

    // Calculate XP needed for the *next* level
    const nextLevelXps = (level + 1) * ((level + 1) + 1) * 50;

    const titles = [ // Index 0 = Level 0-4, Index 1 = Level 5-9, etc.
        'Apprentice', 'Aspiring', 'Novice', 'Enthusiastic', 'Explorer',
        'Code Craftsman', 'Skilled', 'Proficient', 'Champion', 'Quality',
        'Expert', 'Professional', 'Innovative', 'Veteran', 'Rising',
        'Master', 'Conquerer', 'Top Tier', 'Insightful', 'Legendary', 'SUPREME'
    ];
    const titleIndex = Math.min(Math.floor(level / 5), titles.length - 1);

    return {
        level,
        title: titles[titleIndex] || 'Contributor',
        nextLevelXps
    };
};


const determineRole = (totalContributions) => {
  if (totalContributions > 100) return 'Maintainer';
  if (totalContributions > 50) return 'Reviewer';
  return 'Contributor';
};

// calculateStreak can remain the same if needed, but ensure events data is correct
const calculateStreak = (events) => {
  if (!events || events.length === 0) return 0;

    const sortedEventTimestamps = events
      .map((event) => new Date(event.created_at).setHours(0, 0, 0, 0)) // Get date part only
      .filter((timestamp, index, self) => self.indexOf(timestamp) === index) // Get unique dates
      .sort((a, b) => b - a); // Sort descending (most recent first)

    if (sortedEventTimestamps.length === 0) return 0;

    let streak = 0;
    let today = new Date();
    today.setHours(0, 0, 0, 0);
    let currentExpectedTime = today.getTime();

    // Check if latest event was today or yesterday
    if (sortedEventTimestamps[0] === currentExpectedTime || sortedEventTimestamps[0] === currentExpectedTime - 86400000) {
        streak = 1;
        currentExpectedTime = sortedEventTimestamps[0]; // Start checking from the latest event day

        // Iterate through older unique event dates
        for (let i = 1; i < sortedEventTimestamps.length; i++) {
            const previousExpectedTime = currentExpectedTime - 86400000; // Expect event on the day before
            if (sortedEventTimestamps[i] === previousExpectedTime) {
                streak++;
                currentExpectedTime = sortedEventTimestamps[i]; // Update the last found day
            } else {
                break; // Streak broken
            }
        }
    }

    return streak;
};
// REMOVED: calculateTotalTokens (cumulative calculation not needed for allocation trigger)

const Dashboard = () => {
  const [userData, setUserData] = useState(null);
  const [repos, setRepos] = useState([]);
  const [walletAddress, setWalletAddress] = useState(null);
  const [isLoading, setIsLoading] = useState(true); // For initial data load
  // searchParams removed
  const { toast } = useToast();

  const [contributionStats, setContributionStats] = useState({
    totalContributions: 0,
    recentContributions: [],
    streak: 0,
    xps: 0,
    role: 'Contributor',
    level: 0, // Start at level 0
    title: 'Apprentice',
    nextLevelXps: 100 // XP needed for level 1
  });

  // --- State for Reward Mechanism Interaction ---
  const [ucoinBalance, setUcoinBalance] = useState(0); // User's actual balance
  const [isRequestPending, setIsRequestPending] = useState(false); // Is a withdrawal request pending?
  const [pendingAmount, setPendingAmount] = useState(0); // Amount of the pending request
  const [isCheckingStatus, setIsCheckingStatus] = useState(false); // Loading state for status checks

  // --- State for Withdrawal Request UI ---
  const [isRequestDialogOpen, setIsRequestDialogOpen] = useState(false); // Controls the request dialog
  const [withdrawRequestAmount, setWithdrawRequestAmount] = useState(""); // User input for request amount
  const [isRequestingWithdrawal, setIsRequestingWithdrawal] = useState(false); // Loading state for request tx
  const [isWithdrawDialogOpen, setIsWithdrawDialogOpen] = useState(false);

  const [contracts, setContracts] = useState({
    userDatabase: null,
    rewardMechanism: null,
    ucoin: null
  });

  // initializeContracts remains the same
  const initializeContracts = useCallback(async (wallet) => {
    try {
      if (!window.ethereum) throw new Error("Ethereum provider missing.");
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
  
      // Validate addresses before creating contracts
      if (!isAddress(CONTRACT_ADDRESSES.userDatabase) ||
          !isAddress(CONTRACT_ADDRESSES.rewardMechanism) ||
          !isAddress(CONTRACT_ADDRESSES.ucoin)) { // Check UCoin address too
          throw new Error("One or more contract addresses are invalid.");
      }
  
      setContracts({
        userDatabase: new ethers.Contract(CONTRACT_ADDRESSES.userDatabase, UserDatabaseABI.abi, signer),
        rewardMechanism: new ethers.Contract(CONTRACT_ADDRESSES.rewardMechanism, RewardMechanismABI.abi, signer),
        ucoin: new ethers.Contract(CONTRACT_ADDRESSES.ucoin, UCoinABI.abi, signer), // ADD THIS LINE
      });
      console.log("Contracts initialized:", CONTRACT_ADDRESSES);
      return true;
    } catch (error) {
      console.error("Contract initialization error:", error);
      toast({ variant: "destructive", title: "Contract Error", description: error.message || "Failed to initialize contracts." });
      setContracts({ userDatabase: null, rewardMechanism: null, ucoin: null }); // Reset all contracts on error
      return false;
    }
  }, [toast]); // Add toast dependency if not already there

  // connectWallet remains the same
  const connectWallet = useCallback(async () => {
    if (typeof window.ethereum !== "undefined") {
      try {
        await window.ethereum.request({ method: "eth_requestPermissions", params: [{ eth_accounts: {} }] });
        const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
        const wallet = accounts[0];
        setWalletAddress(wallet);
        localStorage.setItem("wallet_address", wallet);
        const success = await initializeContracts(wallet); // Initialize contracts
        if (success) {
            toast({ title: "Wallet Connected", description: `Connected to ${wallet}` });
        }
      } catch (error) {
        console.error("MetaMask Connection Error:", error);
        toast({ variant: "destructive", title: "Connection Failed", description: "Failed to connect wallet." });
      }
    } else {
      // Suggest installing MetaMask
      toast({ variant: "destructive", title: "MetaMask Not Found", description: "Please install the MetaMask extension."});
      // Optionally open link in new tab
      // window.open("https://metamask.io/download.html", "_blank");
    }
  }, [toast, initializeContracts]); // Add dependencies

  // registerUser remains similar, might check if user exists first
   const registerUser = useCallback(async () => {
     if (!contracts.userDatabase || !userData?.login || !walletAddress) {
       console.log("Skipping registration: Missing contracts, user data, or wallet address.");
       return;
     }

     try {
       console.log(`Attempting registration check/set for ${userData.login} on wallet ${walletAddress}`);
       // Optional: Check if user already exists with this wallet to avoid unnecessary tx
       // This requires a getter function in UserDatabase like `getUser(address)`
       // const existingUser = await contracts.userDatabase.users(walletAddress); // Assuming 'users' mapping is public
       // if (existingUser && existingUser.wallet !== address(0)) { // Check if wallet address is non-zero
       //     console.log(`User ${existingUser.username} already registered for wallet ${walletAddress}.`);
       //     return;
       // }

       // If no check or user doesn't exist, proceed to set
       const tx = await contracts.userDatabase.setUser(userData.login);
       toast({ title: "Registering User...", description: `Linking ${userData.login} to your wallet...` });
       await tx.wait();
       toast({ variant: "success", title: "Registration Successful", description: `GitHub user ${userData.login} linked.` });
     } catch (error) {
       console.error("Registration error:", error);
       const reason = error.reason || error.data?.message || error.message || "An unknown error occurred";
       // Don't show error toast if user already exists (depends on contract revert reason)
       if (!reason.toLowerCase().includes("user already exists")) {
           toast({ variant: "destructive", title: "Registration Failed", description: reason });
       } else {
           console.log("Registration skipped: User likely already exists.");
       }
     }
   }, [contracts.userDatabase, userData, walletAddress, toast]);

   const fetchPendingRequestStatus = useCallback(async () => {
    if (!walletAddress || !contracts.rewardMechanism) {
      setIsRequestPending(false); setPendingAmount(0); return;
    }
    setIsCheckingStatus(true);
    try {
      const requestData = await contracts.rewardMechanism.getPendingRequest(walletAddress);
      const currentlyPending = requestData.isPending;
      const requestedAmountBigInt = requestData.amount;
      const requestedAmountFormatted = parseFloat(formatUnits(requestedAmountBigInt, UCOIN_DECIMALS));
      if (currentlyPending !== isRequestPending || requestedAmountFormatted !== pendingAmount) {
        setIsRequestPending(currentlyPending); setPendingAmount(requestedAmountFormatted);
      }
    } catch (error) {
      console.error("[Status Check] Error fetching status:", error);
      setIsRequestPending(false); setPendingAmount(0);
    } finally { setIsCheckingStatus(false); }
  }, [walletAddress, contracts.rewardMechanism, isRequestPending, pendingAmount]);


  // handleWithdraw remains the same (calls claimReward)
  const handleRequestWithdrawal = useCallback(async () => {
    if (!contracts.rewardMechanism || !walletAddress || isRequestPending) {
      toast({ variant: "destructive", title: "Request Error", description: isRequestPending ? "Request already pending." : "Wallet/contract not ready." }); return;
    }
    if (!withdrawRequestAmount || parseFloat(withdrawRequestAmount) <= 0) {
      toast({ variant: "destructive", title: "Invalid Amount", description: "Enter a positive amount." }); return;
    }
    setIsRequestingWithdrawal(true);
    let parsedAmount;
    try {
      parsedAmount = parseUnits(withdrawRequestAmount, UCOIN_DECIMALS);
      toast({ title: "Submitting Request...", description: `Requesting ${withdrawRequestAmount} UCoin...` });
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const rewardContractWithSigner = contracts.rewardMechanism.connect(signer);
      const tx = await rewardContractWithSigner.requestWithdrawal(parsedAmount);
      toast({ title: "Processing Tx", description: `Waiting for confirmation... Tx: ${tx.hash.substring(0, 10)}...` });
      await tx.wait();
      toast({ variant: "success", title: "Withdrawal Requested", description: `Request for ${withdrawRequestAmount} UCoin pending approval.` });
      await fetchPendingRequestStatus(); // Re-fetch status
      setIsRequestDialogOpen(false);
      setWithdrawRequestAmount("");
    } catch (error) {
      console.error("Withdrawal request error:", error);
      let reason = "Transaction failed.";
      if (error.data?.message?.includes("RM_RequestAlreadyPending")) {
          reason = "You already have a pending request."; await fetchPendingRequestStatus();
      } else if (error.data?.message?.includes("RM_AmountMustBePositive")) {
          reason = "Amount must be > 0.";
      } else { reason = error.reason || error.data?.message || error.message || reason; }
      toast({ variant: "destructive", title: "Request Failed", description: reason });
    } finally { setIsRequestingWithdrawal(false); }
  }, [contracts.rewardMechanism, walletAddress, isRequestPending, withdrawRequestAmount, toast, fetchPendingRequestStatus, ucoinBalance]); // Add ucoinBalance if used for checks


  // Load wallet on mount
  useEffect(() => {
    const savedWallet = localStorage.getItem("wallet_address");
    if (savedWallet) {
      setWalletAddress(savedWallet);
      initializeContracts(savedWallet); // Initialize contracts if wallet exists
    }
  }, [initializeContracts]); // Added initializeContracts dependency

  // Register user effect remains the same
  useEffect(() => {
    if (userData?.login && walletAddress && contracts.userDatabase) {
      registerUser();
    }
  }, [userData, walletAddress, contracts.userDatabase, registerUser]); // Added registerUser dependency


  // processGitHubUser remains similar
  const processGitHubUser = useCallback((user) => {
    if (user && user.accessToken && user.username) {
      console.log("Processing GitHub user data for:", user.username);
      localStorage.setItem("github_token", user.accessToken);

      const processedUserData = {
        name: user.displayName || user.username,
        login: user.username,
        avatar_url: user.photos?.[0]?.value || user._json?.avatar_url,
        bio: user._json?.bio || "No bio available",
        public_repos: user._json?.public_repos || 0,
        followers: user._json?.followers || 0,
        following: user._json?.following || 0,
        html_url: user.profileUrl || `https://github.com/${user.username}`,
      };

      setUserData(processedUserData);
      // Trigger fetches that depend on the access token
      fetchRepos(user.accessToken);
      fetchContributionStats(user.accessToken, processedUserData.login); // Pass login too
    } else {
        console.warn("processGitHubUser called without complete user data:", user);
        setIsLoading(false); // Ensure loading stops if data is bad
    }
  }, []); // Empty deps for now, relies on internal calls

  // fetchContributionStats - Modified to initialize previousLevel
  const fetchContributionStats = async (token) => {
    try {
      const query = `
      {
        viewer {
          login
          contributionsCollection {
            contributionCalendar {
              totalContributions
            }
            commitContributionsByRepository {
              repository {
                name
              }
              contributions {
                totalCount
              }
            }
          }
        }
      }`;
  
      const response = await fetch("https://api.github.com/graphql", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ query }),
      });
  
      if (!response.ok) {
        throw new Error("Failed to fetch contribution stats");
      }
  
      const result = await response.json();
      const data = result.data.viewer.contributionsCollection;
  
      const totalContributions = data.contributionCalendar.totalContributions;
  
      const recentContributions = data.commitContributionsByRepository.map((repo) => ({
        type: `Committed to ${repo.repository.name}`,
        created_at: new Date().toISOString(),
      }));
  
      const xps = totalContributions * 50;
      const { level, title, nextLevelXps } = calculateLevelAndTitle(xps);
      const role = determineRole(totalContributions);
      const streak = calculateStreak(recentContributions);
  
      setContributionStats({
        xps,
        level,
        title,
        nextLevelXps,
        totalContributions,
        streak,
        role,
        recentContributions,
      });
    } catch (error) {
      console.error("GitHub contribution fetch error:", error);
      toast({
        variant: "destructive",
        title: "GitHub Error",
        description: "Failed to fetch contribution data.",
      });
    }
  };

// Inside Dashboard component

const fetchUCoinBalance = useCallback(async () => {
  if (!walletAddress) {
      console.log("[Balance Check] Skipped: Wallet not connected.");
      if (ucoinBalance !== 0) setUcoinBalance(0);
      return;
  }
  if (!contracts.ucoin) {
      console.log("[Balance Check] Skipped: UCoin contract not initialized.");
      // Keep existing balance potentially, or reset? Decide based on desired UX.
      // Let's reset for consistency if contract disappears:
      if (ucoinBalance !== 0) setUcoinBalance(0);
      return;
  }

  console.log(`[Balance Check] Fetching balance for ${walletAddress} from ${contracts.ucoin.address}`); // Use address property

  try {
      const balanceBigInt = await contracts.ucoin.balanceOf(walletAddress);
      console.log("[Balance Check] Raw balance (BigInt):", balanceBigInt?.toString()); // Log raw value

      const balanceFormatted = parseFloat(formatUnits(balanceBigInt, UCOIN_DECIMALS));
      console.log("[Balance Check] Formatted balance:", balanceFormatted);

      // Only update state if the value actually changed to prevent unnecessary re-renders
      if (balanceFormatted !== ucoinBalance) {
          console.log(`[Balance Check] Updating balance state from ${ucoinBalance} to ${balanceFormatted}`);
          setUcoinBalance(balanceFormatted);
      } else {
          // console.log("[Balance Check] Balance unchanged."); // Optional: reduce console noise
      }
  } catch (error) {
      console.error("[Balance Check] Error fetching UCoin balance:", error);
      // Reset balance on error to avoid showing stale data
      if (ucoinBalance !== 0) {
           console.log("[Balance Check] Resetting balance to 0 due to error.");
           setUcoinBalance(0);
      }
  }
}, [walletAddress, contracts.ucoin, ucoinBalance]); // Keep ucoinBalance in deps for the comparison check

 // Periodically check UCoin balance and pending request status
useEffect(() => {
  if (walletAddress && contracts.rewardMechanism && contracts.ucoin) { // Check for ucoin contract too
    console.log("[Interval Setup] Setting up balance and status checks.");
    // Initial checks
    fetchUCoinBalance();
    fetchPendingRequestStatus();

    // Set up intervals
    const balanceIntervalId = setInterval(fetchUCoinBalance, 30000); // Check balance every 30s
    const statusIntervalId = setInterval(fetchPendingRequestStatus, 15000); // Check status every 15s

    // Cleanup function
    return () => {
      console.log("[Interval Cleanup] Clearing balance and status checks.");
      clearInterval(balanceIntervalId);
      clearInterval(statusIntervalId);
    };
  } else {
      // Reset state if wallet disconnects or contracts aren't ready
      setUcoinBalance(0);
      setIsRequestPending(false);
      setPendingAmount(0);
  }
  // DEPENDENCIES ARE CRUCIAL HERE
}, [walletAddress, contracts.rewardMechanism, contracts.ucoin, fetchUCoinBalance, fetchPendingRequestStatus]); // Ensure all called functions are dependencies



  // fetchGithubData, fetchUserWithToken, fetchUserWithSession, fetchRepos remain similar
  const loadWallet = useCallback(() => {
    const savedWallet = localStorage.getItem("wallet_address");
    if (savedWallet) {
        setWalletAddress(savedWallet);
        initializeContracts(savedWallet); // Init contracts if wallet is loaded
    }
  }, [initializeContracts]); // Add dependency

  const fetchGithubData = useCallback(async () => {
    setIsLoading(true); // Set loading true at the start
    try {
        const token = localStorage.getItem("github_token");
        if (token) {
            console.log("Attempting GitHub auth with stored token...");
            await fetchUserWithToken(token);
        } else {
            console.log("No token found, attempting auth via backend session...");
            await fetchUserWithSession();
        }
    } catch (error) {
        console.error("Error in fetchGithubData:", error);
        // Errors should be handled within the called functions, but catch here as a fallback
        setIsLoading(false);
    }
    // setIsLoading(false) is handled within fetchUserWithToken/fetchUserWithSession
  }, []); // Empty dependency array initially

    const fetchUserWithToken = useCallback(async (token) => {
        // setIsLoading(true); // Handled by caller fetchGithubData
        try {
            const userRes = await fetch("https://api.github.com/user", {
                headers: { Authorization: `token ${token}` },
            });
            if (!userRes.ok) {
                 if (userRes.status === 401) {
                     console.warn("GitHub token invalid/expired.");
                     localStorage.removeItem("github_token");
                     toast({ variant: "destructive", title: "GitHub Auth Failed", description: "Token invalid. Please reconnect."});
                     // Clear user data if auth fails
                     setUserData(null);
                     setContributionStats(prev => ({ ...prev, level: 0, xps: 0, totalContributions: 0 })); // Reset stats
                     setPreviousLevel(null); // Reset level tracking
                 }
                throw new Error(`Failed to fetch GitHub user data: ${userRes.statusText}`);
            }
            const githubApiData = await userRes.json();
            const userObject = { // Standardize data for processGitHubUser
                accessToken: token,
                username: githubApiData.login,
                displayName: githubApiData.name,
                photos: [{ value: githubApiData.avatar_url }],
                profileUrl: githubApiData.html_url,
                _json: githubApiData,
            };
            processGitHubUser(userObject); // Process data -> fetches stats/repos
        } catch (error) {
            console.error("GitHub token auth error:", error);
            // Don't toast generic errors again if specific 401 handled above
            if (error.message.includes('401')) {
                 // Already handled
            } else {
                 toast({ variant: "destructive", title: "GitHub Fetch Failed", description: error.message });
            }
            setIsLoading(false); // Ensure loading stops on error
        } finally {
             // Moved setIsLoading(false) to processGitHubUser completion and error paths
        }
    }, [processGitHubUser, toast]); // Add dependencies


    const fetchUserWithSession = useCallback(async () => {
       // setIsLoading(true); // Handled by caller fetchGithubData
        try {
            const response = await axios.get('http://localhost:5000/user', { withCredentials: true });
            if (response.data && response.data.accessToken) {
                processGitHubUser(response.data); // Process data -> fetches stats/repos
            } else {
                // No active session found via backend
                console.log("No active GitHub session found via backend.");
                localStorage.removeItem("github_token"); // Clear any stale token
                setUserData(null);
                setIsLoading(false); // Stop loading if no session
            }
        } catch (error) {
            console.error("GitHub session auth error:", error.response?.data?.error || error.message);
             // Don't toast if it's just a 401 (user not logged in)
             if (error.response?.status !== 401) {
                 toast({ variant: "warning", title: "Session Check Failed", description: "Could not check GitHub session."});
             }
             localStorage.removeItem("github_token");
             setUserData(null);
             setIsLoading(false); // Stop loading on error
        }
    }, [processGitHubUser, toast]); // Add dependencies

    const fetchRepos = useCallback(async (token) => {
       if (!token) return;
       try {
           // Fetch 3 most recently updated repos
           const reposRes = await fetch("https://api.github.com/user/repos?sort=updated&per_page=3", {
               headers: { Authorization: `token ${token}` }
           });
           if (!reposRes.ok) throw new Error(`Failed to fetch repositories: ${reposRes.statusText}`);
           const reposData = await reposRes.json();
           setRepos(reposData);
       } catch (error) {
           console.error("GitHub repos fetch error:", error);
           toast({ variant: "destructive", title: "Repo Fetch Error", description: "Failed to fetch repository data." });
       } finally {
            // This might turn off loading too early if fetchContributionStats is still running
            // Consider a more robust loading state management if needed
            setIsLoading(false);
       }
   }, [toast]); // Add dependency

  // fetchContributions removed (integrated into fetchContributionStats logic)

  // Initial data load effect
  useEffect(() => {
    console.log("Dashboard loading...");
    loadWallet(); // Load wallet first, which initializes contracts if found

    // Check for OAuth redirect completion (backend now redirects directly, frontend calls /user)
    // The old logic parsing URL params is removed.

    fetchGithubData(); // Fetch GitHub data (checks token/session)

  }, [loadWallet, fetchGithubData]); // Run once on mount


 // Add these state variables at the top of your component
const [isOwner, setIsOwner] = useState(false);
const [pendingWithdrawals, setPendingWithdrawals] = useState([]);
const [pendingWithdrawalsLoading, setPendingWithdrawalsLoading] = useState(false);
const [isApproving, setIsApproving] = useState(false);

// Update the owner check useEffect
useEffect(() => {
  const checkOwnerStatus = async () => {
    if (walletAddress && contracts.rewardMechanism) {
      try {
        const owner = await contracts.rewardMechanism.owner();
        const isOwner = owner.toLowerCase() === walletAddress.toLowerCase();
        setIsOwner(isOwner);
        
        // Only fetch if owner
        if (isOwner) {
          await fetchPendingWithdrawals();
        }
      } catch (error) {
        console.error("Error checking owner status:", error);
      }
    }
  };
  
  checkOwnerStatus();
}, [walletAddress, contracts.rewardMechanism]);

// Dashboard.jsx

useEffect(() => {
  const checkOwnerStatus = async () => {
      if (walletAddress && contracts.rewardMechanism) {
          try {
              console.log("Checking owner status...");
              const owner = await contracts.rewardMechanism.owner();
              console.log("Contract Owner:", owner);
              console.log("Connected Wallet:", walletAddress);
              const isOwnerCheck = owner.toLowerCase() === walletAddress.toLowerCase();
              console.log("Is Owner?", isOwnerCheck);
              setIsOwner(isOwnerCheck); // Set state

              if (isOwnerCheck) {
                  console.log("User is owner, fetching pending withdrawals...");
                  await fetchPendingWithdrawals(); // Call fetch if owner
              } else {
                   setPendingWithdrawals([]); // Clear pending if not owner
              }
          } catch (error) {
              console.error("Error checking owner status:", error);
              setIsOwner(false); // Assume not owner on error
              setPendingWithdrawals([]); // Clear pending on error
          }
      } else {
           console.log("Skipping owner check: Wallet or contract not ready.");
           setIsOwner(false); // Reset owner status if wallet disconnects/contract not ready
           setPendingWithdrawals([]); // Clear pending
      }
  };

  checkOwnerStatus();
  // Dependencies: Run when wallet or contract instance changes
}, [walletAddress, contracts.rewardMechanism]); // fetchPendingWithdrawals is called internally, no need to add here if not memoized


const fetchPendingWithdrawals = async () => {
  // No need to check isOwner here again, as it's called conditionally
  setPendingWithdrawalsLoading(true);
  console.log("Calling backend API: /api/pending-withdrawals");
  try {
      // Ensure you're using the correct base URL if deployed
      const response = await axios.get('/api/pending-withdrawals', {
          withCredentials: true // Important for ensureAuthenticated
      });
      console.log("Backend response for pending withdrawals:", response.data);
      setPendingWithdrawals(response.data.pendingRequests || []); // Ensure it's an array
  } catch (error) {
      console.error("Error fetching pending withdrawals:", error.response?.data || error.message); // Log specific error
      toast({
          variant: "destructive",
          title: "Fetch Failed",
          description: error.response?.data?.error || "Could not load pending withdrawals"
      });
      setPendingWithdrawals([]); // Clear on error
  } finally {
      setPendingWithdrawalsLoading(false);
  }
};

// Make sure approveWithdrawal uses the correct endpoint and data
const approveWithdrawal = async (userAddress) => {
  if (!userAddress) {
       console.error("approveWithdrawal called with no userAddress");
       return;
  }
  setIsApproving(true); // Use a state variable specific to the button if needed, or a global one
  console.log(`Calling backend API: POST /api/approve-withdrawal for user ${userAddress}`);
  try {
      const response = await axios.post('/api/approve-withdrawal',
        { userAddress }, // Send userAddress in the body
        { withCredentials: true } // Important for ensureAuthenticated
      );
      console.log("Backend response for approval:", response.data);

      toast({
        variant: "success", // Use success variant
        title: "Approval Sent",
        description: `Approval tx ${response.data.txHash ? `(${response.data.txHash.substring(0,10)}...) ` : ''}sent for ${userAddress}.`,
      });

      // Refresh the list after a short delay to allow blockchain update/backend cache
      setTimeout(() => {
          fetchPendingWithdrawals();
      }, 3000); // Adjust delay as needed

  } catch (error) {
      console.error("Error approving withdrawal:", error.response?.data || error.message);
      toast({
        variant: "destructive",
        title: "Approval Failed",
        description: error.response?.data?.details || error.response?.data?.error || "Failed to approve withdrawal",
      });
  } finally {
      // Consider setting approving state per-button or resetting after fetch
      setIsApproving(false);
  }
};

useEffect(() => {
  const verifyContract = async () => {
    if (contracts.rewardMechanism) {
      try {
        const owner = await contracts.rewardMechanism.owner();
        console.log("Contract owner:", owner);
      } catch (error) {
        console.error("Contract connection error:", error);
      }
    }
  };
  verifyContract();
}, [contracts.rewardMechanism]);

  // New state for tracking withdrawal transactions
const [withdrawalHistory, setWithdrawalHistory] = useState([]);

// Fetch withdrawal history (add to your useEffect that checks wallet/contracts)
const fetchWithdrawalHistory = useCallback(async () => {
  if (!walletAddress || !contracts.rewardMechanism) return;
  
  try {
    const filter = contracts.rewardMechanism.filters.WithdrawalCompleted(walletAddress);
    const events = await contracts.rewardMechanism.queryFilter(filter);
    
    const history = events.map(event => ({
      amount: formatUnits(event.args.amount, UCOIN_DECIMALS),
      timestamp: (event.getBlock()).timestamp * 1000, // Convert to ms
      txHash: event.transactionHash
    }));
    
    setWithdrawalHistory(history);
  } catch (error) {
    console.error("Error fetching withdrawal history:", error);
  }
}, [walletAddress, contracts.rewardMechanism]);


  // --- Render ---
  return (
  <div className="min-h-screen bg-background">
  <Navbar />
  <main className="pt-24 px-4 max-w-7xl mx-auto pb-12"> {/* Added padding-bottom */}
  
        
  {/* Central Loading Indicator */}
       {isLoading && (
           <div className="flex justify-center items-center my-16">
               <Loader2 className="h-10 w-10 animate-spin text-primary" />
               <p className="ml-4 text-lg text-muted-foreground">Loading Dashboard...</p>
           </div>
       )}
  
       {/* Render content only when initial load is complete */}
       {!isLoading && (
          <>
            {/* --- Top Row Stats --- */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Level Progress Card (Unchanged) */}
                <Card className="glass">
                  <CardHeader>
                    <CardTitle>Level Progress</CardTitle>
                     <CardDescription>{contributionStats.title}</CardDescription>
                  </CardHeader>
                  <CardContent>
                    <Progress value={contributionStats.nextLevelXps > 0 ? Math.min(100, (contributionStats.xps / contributionStats.nextLevelXps) * 100) : (contributionStats.level > 0 ? 100 : 0)} />
                    <p className="text-sm text-muted-foreground mt-2">
                      Level: <span className="font-semibold">{contributionStats.level}</span> |
                      XP: <span className="font-semibold">{contributionStats.xps}</span> / {contributionStats.nextLevelXps}
                    </p>
                     {contributionStats.nextLevelXps > contributionStats.xps && contributionStats.nextLevelXps > 0 && (
                         <p className="text-xs text-muted-foreground">
                             {contributionStats.nextLevelXps - contributionStats.xps} XP to Level {contributionStats.level + 1}
                         </p>
                     )}
                  </CardContent>
                </Card>
  
                {/* Contribution Overview Card (Unchanged) */}
                <Card className="glass">
                  <CardHeader>
                    <CardTitle>Contribution Overview</CardTitle>
                     <CardDescription>Summary of activity</CardDescription>
                  </CardHeader>
                  <CardContent>
                     <p className="text-lg">Role: <Badge variant="secondary">{contributionStats.role}</Badge></p>
                     <p className="mt-2">Total Contributions: <span className="font-semibold">{contributionStats.totalContributions}</span></p>
                     <p className="mt-2">Total XPs: <span className="font-semibold">{contributionStats.xps}</span></p>
                     <p className="mt-1">Current Streak: <span className="font-semibold">{contributionStats.streak}</span> {contributionStats.streak === 1 ? 'day' : 'days'}</p>
                  </CardContent>
                </Card>
  
                {/* ----------------------------------------- */}
                {/* --- UCoin Wallet & Rewards Card (MODIFIED) --- */}
                {/* ----------------------------------------- */}
                { !isOwner && (<Card className="glass">
                  <CardHeader>
                    {/* Changed Title and Description */}
                    <CardTitle>UCoin Wallet & Rewards</CardTitle>
                    <CardDescription>Balance and withdrawal requests</CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-4">
  
                      {/* UCoin Balance Display */}
                      <div className="flex justify-between items-center">
                        <span className="text-muted-foreground flex items-center gap-1">
                           {/* Added Wallet Icon */}
                           <Wallet className="h-4 w-4" /> Your Balance:
                        </span>
                        <span className="text-xl font-bold">
                          {/* Display formatted ucoinBalance state */}
                          {ucoinBalance} UCoin
                        </span>
                      </div>
  
                      <hr />
  
                      {/* Withdrawal Request Section */}
                      <div>
                        <Label className="flex items-center gap-1 mb-2">
                            {/* Added Help Icon */}
                            <CircleHelp className="h-4 w-4 text-muted-foreground" />
                            Withdrawal Status
                        </Label>
  
                        {/* Show loading spinner while checking status */}
                        {isCheckingStatus && (
                           <div className="flex items-center text-sm text-muted-foreground">
                             <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Checking status...
                           </div>
                        )}
  
                        {/* Show pending status if applicable */}
                        {!isCheckingStatus && isRequestPending && (
                            <div className="p-3 bg-yellow-100 dark:bg-yellow-900/30 border border-yellow-300 dark:border-yellow-700 rounded-md text-yellow-800 dark:text-yellow-200">
                               <div className="flex items-center gap-2 font-medium">
                                    {/* Added Clock Icon */}
                                    <Clock className="h-5 w-5" />
                                    Request Pending Owner Approval
                               </div>
                               <p className="text-sm mt-1">Amount: <strong>{pendingAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} UCoin</strong></p>
                               <p className="text-xs mt-1">The contract owner must approve this request.</p>
                            </div>
                        )}
  
                        {/* Show request button/dialog if no request is pending */}
                        {!isCheckingStatus && !isRequestPending && (
                            <div className="space-y-3">
                                <p className="text-sm text-muted-foreground">You have no pending withdrawal requests.</p>
                                {/* Dialog for Requesting Withdrawal */}
                                <Dialog open={isRequestDialogOpen} onOpenChange={setIsRequestDialogOpen}>
                                  <DialogTrigger asChild>
                                    <Button
                                      variant="default"
                                      // Disable button if wallet/contract not ready OR if a request is somehow pending
                                      disabled={!walletAddress || !contracts.rewardMechanism || isRequestPending}
                                      className="w-full"
                                    >
                                        Request Withdrawal
                                    </Button>
                                  </DialogTrigger>
                                  <DialogContent className="sm:max-w-[425px]">
                                    <DialogHeader>
                                      <DialogTitle>Request UCoin Withdrawal</DialogTitle>
                                      <DialogDescription>
                                        Enter the amount of UCoin you wish to withdraw. This request requires owner approval.
                                      </DialogDescription>
                                    </DialogHeader>
                                    <div className="grid gap-4 py-4">
                                        <div className="grid grid-cols-4 items-center gap-4">
                                            <Label htmlFor="request-amount" className="text-right">Amount</Label>
                                            <Input
                                                id="request-amount"
                                                type="number"
                                                min="0"
                                                step="any" // Allow decimals
                                                // Bind value to state variable
                                                value={withdrawRequestAmount}
                                                // Update state variable on change
                                                onChange={(e) => setWithdrawRequestAmount(e.target.value)}
                                                className="col-span-3"
                                                placeholder="e.g., 100.5"
                                                // Disable input while submitting
                                                disabled={isRequestingWithdrawal}
                                            />
                                        </div>
                                        {/* Display user's current balance for context */}
                                        <p className="text-xs text-muted-foreground col-span-4 px-1">Your current balance: {ucoinBalance} UCoin</p>
                                        <p className="text-xs text-muted-foreground col-span-4 px-1">Request will be sent for address: <code className="text-xs">{walletAddress}</code></p>
                                    </div>
                                    <DialogFooter>
                                      <Button variant="outline" onClick={() => setIsRequestDialogOpen(false)} disabled={isRequestingWithdrawal}>Cancel</Button>
                                      <Button
                                        type="button"
                                        // Call the NEW request handler function
                                        onClick={handleRequestWithdrawal}
                                        // Disable button during submission or if amount is invalid
                                        disabled={isRequestingWithdrawal || !withdrawRequestAmount || parseFloat(withdrawRequestAmount) <= 0}
                                      >
                                        {/* Show loading state on button */}
                                        {isRequestingWithdrawal ? (
                                          <span className="flex items-center"><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Submitting...</span>
                                        ) : ( "Confirm Request" )}
                                      </Button>
                                    </DialogFooter>
                                  </DialogContent>
                                </Dialog>
                            </div>
                        )}
                      </div>
                    </div>
                  </CardContent>
                </Card>
                )}
                {/* ----------------------------------------- */}
                {/* --- End of Modified Card --- */}
                {/* ----------------------------------------- */}
            </div>
  
            {/* --- Second Row: Wallet & GitHub (Unchanged) --- */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                {/* Wallet Card */}
                <Card className="glass">
                  <CardHeader><CardTitle className="flex items-center gap-2"><Wallet className="h-6 w-6" /> Wallet</CardTitle></CardHeader>
                  <CardContent>
                    {walletAddress ? (
                      <div className="space-y-3">
                        <p className="text-sm font-mono break-all bg-muted p-2 rounded">{walletAddress}</p>
                        <div className="flex gap-2 flex-wrap">
                          <Button variant="outline" size="sm" onClick={() => { navigator.clipboard.writeText(walletAddress); toast({ title: "Copied!" }); }}>Copy</Button>
                          <Button variant="outline" size="sm" onClick={() => { window.open(`https://sepolia.etherscan.io/address/${walletAddress}`, '_blank'); }}>
                              View on Explorer <ExternalLink className="h-3 w-3 ml-1" />
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <Button onClick={connectWallet} className="gap-2 w-full md:w-auto"><Wallet className="h-4 w-4" /> Connect Wallet</Button>
                    )}
                  </CardContent>
                </Card>
  
                {/* GitHub Profile Card */}
                <Card className="glass">
                  <CardHeader><CardTitle className="flex items-center gap-2"><Github className="h-6 w-6" /> GitHub Profile</CardTitle></CardHeader>
                  <CardContent>
                    {userData ? (
                      <div className="flex flex-col space-y-4">
                        <div className="flex items-start sm:items-center gap-4 flex-col sm:flex-row">
                          {userData.avatar_url && <img src={userData.avatar_url} className="w-16 h-16 rounded-full border" alt="Avatar"/>}
                          <div className="flex-grow">
                            <h3 className="text-xl font-bold">{userData.name || userData.login}</h3>
                            {userData.login && <p className="text-sm text-muted-foreground">@{userData.login}</p>}
                            <p className="text-sm text-muted-foreground mt-1">{userData.bio || "No bio."}</p>
                            <div className="flex gap-2 mt-2 flex-wrap">
                              <Badge variant="secondary">{userData.public_repos || 0} repos</Badge>
                              <Badge variant="secondary">{userData.followers || 0} followers</Badge>
                              <Badge variant="secondary">{userData.following || 0} following</Badge>
                            </div>
                          </div>
                        </div>
                        <Button asChild variant="outline" className="w-full md:w-auto self-start">
                          <a href={userData.html_url} target="_blank" rel="noopener noreferrer" className="flex items-center gap-2">
                            <ExternalLink className="h-4 w-4" /> View on GitHub
                          </a>
                        </Button>
                      </div>
                    ) : (
                      <div className="flex flex-col items-center justify-center h-24 gap-3 text-center">
                        <p className="text-muted-foreground">Connect GitHub to track stats & level up.</p>
                        <Button asChild>
                          <a href="http://localhost:5000/auth/github" className="inline-flex items-center space-x-2"><Github className="h-4 w-4" /><span>Connect GitHub</span></a>
                        </Button>
                      </div>
                    )}
                  </CardContent>
                </Card>
            </div>
  
            {/* --- Repositories & Activity (Show only if GitHub connected) (Unchanged) --- */}
            {userData && (
              <>
                {/* Repositories Card */}
                {repos.length > 0 && (
                   <div className="mt-6">
                       <Card className="glass">
                         <CardHeader><CardTitle>Recent Repositories</CardTitle><CardDescription>Last 3 updated</CardDescription></CardHeader>
                         <CardContent>
                           <div className="space-y-4">
                             {repos.map(repo => (
                               <div key={repo.id} className="border rounded-lg p-4 hover:bg-muted/50 transition-colors">
                                 <div className="flex justify-between items-start gap-2">
                                   <div className="flex-grow">
                                     <h3 className="font-medium text-primary flex items-center gap-1 flex-wrap">
                                       <a href={repo.html_url} target="_blank" rel="noopener noreferrer" className="hover:underline break-all">
                                          {repo.owner.login}/{repo.name} <ExternalLink className="h-4 w-4 inline-block flex-shrink-0" />
                                       </a>
                                     </h3>
                                     <p className="text-sm text-muted-foreground mt-1">{repo.description || 'No description.'}</p>
                                   </div>
                                   <Badge variant={repo.private ? 'outline' : 'secondary'} className="flex-shrink-0">{repo.private ? 'Private' : 'Public'}</Badge>
                                 </div>
                                 <div className="flex flex-wrap gap-x-4 gap-y-1 text-xs text-muted-foreground mt-3">
                                   {repo.language && <div className="flex items-center gap-1"><Code className="h-3 w-3" /><span>{repo.language}</span></div>}
                                   <div className="flex items-center gap-1"><Star className="h-3 w-3" /><span>{repo.stargazers_count}</span></div>
                                   <div className="flex items-center gap-1"><GitFork className="h-3 w-3" /><span>{repo.forks_count}</span></div>
                                   <span>Updated: {new Date(repo.updated_at).toLocaleDateString()}</span>
                                 </div>
                               </div>
                             ))}
                           </div>
                         </CardContent>
                       </Card>
                   </div>
                )}
  
                {/* Recent Activity Card */}
                <div className="mt-6">
                  <Card className="glass">
                    <CardHeader><CardTitle>Recent GitHub Activity</CardTitle><CardDescription>Latest public events</CardDescription></CardHeader>
                    <CardContent>
                      {contributionStats.recentContributions.length > 0 ? (
                        <div className="space-y-3">
                          {contributionStats.recentContributions.map((activity, index) => (
                            <div key={index} className="flex items-start gap-3 text-sm">
                              <div className="flex-shrink-0 h-2 w-2 mt-[6px] rounded-full bg-primary" />
                              <div className="flex-grow">
                                {activity.url ? (
                                  <a href={activity.url} target="_blank" rel="noopener noreferrer" className="hover:underline text-primary">
                                    {activity.type} <ExternalLink className="h-3 w-3 inline-block ml-1" />
                                  </a>
                                ) : ( <span>{activity.type}</span> )}
                                <p className="text-xs text-muted-foreground">{new Date(activity.created_at).toLocaleString()}</p>
                              </div>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <p className="text-muted-foreground">No recent public activity found.</p>
                      )}
                    </CardContent>
                  </Card>
                </div>
                {isOwner && (
  <div className="mt-6">
    <Card className="glass">
      <CardHeader>
        <CardTitle>Owner Dashboard</CardTitle>
        <CardDescription>Manage Withdrawal Requests</CardDescription>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="pending">
          <TabsList className="grid grid-cols-2 w-[200px]">
            <TabsTrigger value="pending">Pending</TabsTrigger>
            <TabsTrigger value="history">History</TabsTrigger>
          </TabsList>
          
          <TabsContent value="pending">
            {/* Existing pending requests table */}
            {pendingWithdrawals.map((request) => (
              <div key={request.txHash} className="flex items-center justify-between p-4 border rounded-lg mb-2">
                <div>
                  <p className="font-medium">{request.user}</p>
                  <p className="text-sm">{request.amount} UCoin</p>
                  <p className="text-xs text-muted-foreground">
                    {new Date(request.requestTimestamp * 1000).toLocaleString()}
                  </p>
                </div>
                <Button 
                  onClick={() => approveWithdrawal(request.user)}
                  disabled={isApproving}
                  size="sm"
                >
                  {isApproving ? <Loader2 className="h-4 w-4 animate-spin" /> : "Approve"}
                </Button>
              </div>
            ))}
          </TabsContent>
          
          <TabsContent value="history">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>User</TableHead>
                  <TableHead>Amount</TableHead>
                  <TableHead>Date</TableHead>
                  <TableHead>TX Hash</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {withdrawalHistory.map((item) => (
                  <TableRow key={item.txHash}>
                    <TableCell>{item.user}</TableCell>
                    <TableCell>{item.amount} UCoin</TableCell>
                    <TableCell>{new Date(item.timestamp).toLocaleString()}</TableCell>
                    <TableCell>
                      <a 
                        href={`https://sepolia.etherscan.io/tx/${item.txHash}`} 
                        target="_blank"
                        rel="noopener"
                        className="text-primary hover:underline"
                      >
                        {item.txHash.substring(0, 8)}...
                      </a>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  </div>
)}
              </>
            )}
          </>
       )}
    </main>
  </div>
  );
}
  export default Dashboard;